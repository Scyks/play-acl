{
  "name": "Play ACL",
  "tagline": "Lightweight and flexible Play Framework ACL moudle",
  "body": "# Play Acl Module\r\n\r\nThis is a module to implement a simple Acl system to play framework. With this\r\nmodule, you can protect controller actions, or anything else.\r\n\r\nYou can protect an admin area, or hide information / actions for specific users.\r\nIt's also possible to connect a right to specific conditions for objects.\r\n\r\nLet's say you have a shop system and want to display orders. The orders are separated\r\nin 2 lists (open orders and closed orders). For this case you can use the acl system\r\nto filter entries between these 2 lists.\r\n\r\n# Install\r\n\r\nYou can easily use the sbt tool to download the resources to your project.\r\n\r\n```scala\r\nlibraryDependencies  ++=  Seq(\r\n\t\"com.github.scyks\" %% \"playacl\" % \"0.5.0\"\r\n)\r\n```\r\n\r\n# How does the ACL system work\r\n\r\nThe Acl system is based on classical roles. A user can have one or more roles. Each role\r\nhave resources and privileges. A resource is a entity or an are / module to separate\r\nrights. A privilege is the action the user want to do, like read, update, delete, expand,\r\nmanage, send, ... .\r\n\r\nA User have roles, and will be initialized with the ACL system. An Anonymous user is also\r\na representation of a user, but with none or different roles.\r\n\r\nRoles are objects, with a unique identifier which. The identifier is a bit value like\r\n1, 2, 4, 8, 16 ...\r\n\r\n## Define resources\r\n\r\nA resource have to extend `com.github.scyks.playacl.Resource` and contain a string identifier.\r\n\r\n```scala\r\nobject AdminResource extends com.github.scyks.playacl.Resource(\"admin\")\r\n```\r\n\r\n## Define Privileges\r\n\r\nA privilege have to extend `com.github.scyks.playacl.Privilege` and contain a string identifier.\r\n \r\n```scala\r\nobject ReadPrivilege extends com.github.scyks.playacl.Privilege(\"read\")\r\n```\r\n\r\n## Define Roles\r\n\r\nA Role have to implement `com.github.scyks.playacl.Role` interface, which contains 4 abstract methods:\r\n\r\n* `getIdentifier: Long`: the role identifier bit value\r\n* `getRoleId: String`: returns a string identifier of this role\r\n* `getInheritedRole: List[Role]`: a list of parent roles\r\n* `getPrivileges: Map[Resource, Map[Privilege, Seq[(Option[AclObject], Acl) => Boolean]]]`: the complete definition of rights\r\n\r\n### Assertions\r\n\r\nAssertions, defined in `Seq[(Option[AclObject], Acl) => Boolean]` are callback functions to define\r\nspecific conditions on a resource. When you have a list of users, and want to show an edit button\r\nto directly edit this user u can use this. An admin will have no restriction, an anonymous user\r\nis denied for this operation, but a user can edit his own entry.\r\n\r\n```scala\r\nval myId = 4\r\ncase class User(id: Int) extends AclObject\r\n// the assert definition\r\n(user: Option[AclObject], acl: Acl) => user match {\r\n\tcase Some(u: User) => u.exists(_.id == acl.observerEntity.id)\r\n\tcase _ => false\r\n}\r\n\r\nacl.isAllowed(UserResource, EditPrivilege, Some(currentUser)) // returns true or false\r\n```\r\n\r\nThis is definitely not a good way to do this, and i'm currently working on\r\na solution to define this in an easier way. If someone have an idea, please let me know.\r\n\r\n## The Security Trait\r\n\r\nFor Initialization of the Acl you need to configure the Security Trait. This Trait will be used\r\nin a controller action to initialize and retrieve the ACL instance for the current user. When there\r\nis no user logged in, there is a guest user defined. To implement the Security trait you need to\r\ndefine these methods:\r\n\r\n* `userByUsername(username: String)(implicit acl: Acl): Option[I]` to retrieve a user from some storage by given username\r\n* `roles: List[Role]` the list of available roles\r\n* `guestRole: Role` the guest role\r\n* `guestUser: UserEntity` to return a guest / anonymous user\r\n\r\n## Putting all Together\r\n\r\nTo configure your acl system you have to define \"Resources\", \"Privileges\", \"Roles\" and the \"Security\" trait.\r\nI'll show a dummy implementation:\r\n\r\n```scala\r\nimport org.playscala.{Resource, Privilege, Role, Identity}\r\nimport org.playscala.play.Security\r\n\r\n/** Resources */\r\nobject MainResource extends Resource(\"main\")\r\nobject UserResource extends Resource(\"user\")\r\nobject AdminResource extends Resource(\"admin\")\r\n\r\n/** Privileges */\r\nobject ReadPrivilege extends Privilege(\"read\")\r\nobject CreatePrivilege extends Privilege(\"create\")\r\nobject LoggedInPrivilege extends Privilege(\"loggedIn\")\r\nobject ManagePrivilege extends Privilege(\"manage\")\r\n\r\n/** User Roles */\r\nobject Guest extends Role {\r\n\r\n\toverride def getIdentifier: Long = 1L\r\n\toverride def getPrivileges: Map[Resource, Map[Privilege, Seq[(Option[AclObject], Acl) => Boolean]]] = {\r\n\t\tMap(\r\n\t\t\tMainResource -> Map(\r\n\t\t\t\tReadPrivilege -> Seq()\r\n\t\t\t),\r\n\t\t\tUserResource -> Map(\r\n\t\t\t\tReadPrivilege -> Seq(),\r\n\t\t\t\tCreatePrivilege -> Seq()\r\n\t\t\t)\r\n\t\t)\r\n\t}\r\n\toverride def getInheritedRoles: List[Role] = List()\r\n\toverride def getRoleId: String = \"guest\"\r\n}\r\nobject Registered extends Role {\r\n\r\n\toverride def getIdentifier: Long = 2L\r\n\toverride def getPrivileges: Map[Resource, Map[Privilege, Seq[(Option[AclObject], Acl) => Boolean]]] = {\r\n\t\tMap(\r\n\t\t\tUserResource -> Map(\r\n\t\t\t\tLoggedInPrivilege -> Seq()\r\n\t\t\t)\r\n\t\t)\r\n\t}\r\n\toverride def getInheritedRoles: List[Role] = List(Guest)\r\n\toverride def getRoleId: String = \"registered\"\r\n}\r\n\r\nobject Admin extends Role {\r\n\t\r\n\toverride def getIdentifier: Long = 4L\r\n\toverride def getPrivileges: Map[Resource, Map[Privilege, Seq[(Option[AclObject], Acl) => Boolean]]] = {\r\n\t\tMap(\r\n\t\t\tAdminResource -> Map(\r\n\t\t\t\tReadPrivilege -> Seq(),\r\n\t\t\t\tManagePrivilege -> Seq()\r\n\t\t\t)\r\n\t\t)\r\n\t} \r\n\toverride def getInheritedRoles: List[Role] = List(Registered)\r\n\toverride def getRoleId: String = \"admin\"\r\n}\r\n\r\ncase class UserEntity(id: Int, roles: Long) extends Identity\r\n\r\ntrait Security extends net.cc.base.acl.play.Security {\r\n\toverride def userByUsername(username: String)(implicit acl: Acl): Option[UserEntity] = {\r\n\t\tUserRepository.findByUserName(username) match {\r\n\t\t\tcase Success(user) => Some(user)\r\n\t\t\tcase Failure(ex) => None\r\n\t\t}\r\n\t}\r\n\toverride def roles: List[Role] = Guest :: Registered :: Admin:: Nil\r\n\toverride def guestRole: Role = Guest\r\n\toverride def guestUser: UserEntity = new UserEntity(0, 1L)\r\n\toverride def onUnauthenticated(request: RequestHeader) = Results.Redirect(\"/login\")\r\n\toverride def onUnauthorized(request: RequestHeader) = Results.Redirect(\"/login\")\r\n}\r\n```\r\n\r\n# Protecting Controller instances or get ACL instance\r\n\r\nBecause of being stateless, the controller is the entry point for the ACL system and \r\nit will be initialized there. Also when you want to retrieve the logged in user.\r\n\r\nThe Standard implementation contains 4 Methods, which are checking if a user is logged in\r\nand return the Acl or the user instance or even check a resource and privilege directly.\r\n\r\n* `withAuth`: check if user is logged in, otherwise `onUnauthenticated` will be called\r\n* `withUser`: will provide the logged in or the guest user instance\r\n* `withAcl`: will provide the acl instance\r\n* `withProtected(r: Resource, p: Privilege)`: \r\n    * if acl check against resource privilege fails -> `onUnauthorized` will be called\r\n* `withProtected(r: Resource, p: Privilege, objectToCheck: () => Option[AclObject])`: \r\n    * if acl check against resource privilege on objecttoCheck fails -> `onUnauthorized` will be called\r\n* `withProtectedAcl(r: Resource, p: Privilege)`: \r\n    * if acl check against resource privilege fails -> `onUnauthorized` will be called\r\n    * if logged in and acl check is true -> return Acl Instance\r\n* `withProtectedAcl(r: Resource, p: Privilege, objectToCheck: () => Option[AclObject])`: \r\n    * if acl check against resource privilege on objectToCheck fails -> `onUnauthorized` will be called\r\n    * if logged in and acl check is true -> return Acl Instance\r\n    \r\n\r\n# Implementation in controller\r\n\r\nTo protect a controller action or retrieve Acl or current user, see the following example:\r\n\r\n```scala\r\npackage controllers\r\n\r\nimport <your security trait>\r\nimport <your resources and privileges>\r\nimport <your user entity>\r\nimport com.github.scyks.playacl.Acl\r\n\r\n/** Admin controller - we want to protected this */\r\nclass Admin @Inject()(val messagesApi: MessagesApi) extends Controller with Security {\r\n\r\n\tdef dashboard = withAuth { implicit request =>\r\n\t\tOk(\"\")\r\n\t}\r\n\t\r\n\tdef dashboard = withUser { implicit user: UserEntity => implicit request =>\r\n\t\tOk(\"\")\r\n\t}\r\n\t\r\n\tdef dashboard = withAcl { implicit acl: Acl => implicit request =>\r\n\t\tOk(\"\")\r\n\t}\r\n\t\r\n\tdef dashboard = withProtected(AdminResource, ReadPrivilege) { implicit request =>\r\n    \tOk(\"\")\r\n\t}\r\n\t\r\n\tdef dashboard = withProtected(AdminResource, ReadPrivilege, DataSource.getData) { implicit request =>\r\n    \tOk(\"\")\r\n\t}\r\n\r\n\tdef dashboard = withProtectedAcl(AdminResource, ReadPrivilege) { implicit acl: Acl => implicit request =>\r\n    \tOk(\"\")\r\n\t}\r\n\t\r\n\tdef dashboard = withProtectedAcl(AdminResource, ReadPrivilege, DataSource.getData) { implicit acl: Acl => implicit request =>\r\n    \tOk(\"\")\r\n\t}\r\n}\r\n```\r\n\r\n# Using acl protection in views / controller\r\n\r\nA Requirement for doing this is an instance of `acl: Acl` in the current context. The acl object\r\nwill be passed as `implicit` parameter.\r\n\r\nFor checking the rights you have a lot of options to ask:\r\n\r\n* `acl.isAllowed(Resource, Privilege, Some(AclObject))`\r\n\r\n__use `AllowLike` trait__\r\n\r\nTo use this `AllowLike` trait, you need an AclObject.\r\n\r\n`case class User extends AclObject With AllowLike`\r\n\r\n* `acl allows Resource to Privilege`\r\n* `acl allows Privilege at Resource`\r\n* `acl allows AclObject ad Resource to Privilege`\r\n* `AclObject allows Resource to Privilege`\r\n* `AclObject allows Privilege at Resource`\r\n* `Resource allows Privilege`\r\n* `Resource allows AclObject to Privilege`\r\n* `Privilege allows Resource`\r\n* `Privilege allows AclObject at Resource`\r\n\r\n## View implementation\r\n\r\nIn a view it's necessary to provide implicit acl instance.\r\n\r\n__without request__\r\n\r\n```scala\r\n@import com.github.scyks.playacl.Acl\r\n@()(implicit acl: Acl)\r\n\r\n@if(acl allows Resource to Privilege) {\r\n\t<h1>Hello World</h1>\r\n}\r\n```\r\n\r\n__with request__\r\n\r\n```scala\r\n@import com.github.scyks.playacl.Acl\r\n@()(implicit request: RequestHeader, acl: Acl)\r\n\r\n@if(acl allows Resource to Privilege) {\r\n\t<h1>Hello World</h1>\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}